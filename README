## README H30.2.22 y-kimura

あんまり説明する気がなくて申し訳ない。。。
大まかに説明する。

ソフトコアのジャミング転移シミュレーション(2D,3D,要C++のcompiler) ... FIREprogram/
可視化(2D,3D粒子座標・固有ベクトル等,2Dはシミュレーションもできる, 要Qt5.6以上) ... FIREprogram/GUI0804 (2D) simple-cpp (3D)
統計処理(要C++のCompiler,新しめのbash) ... Analysis/
gnuplotマクロ(gnuplot5以上) ... G_macro/
サンプル沢山とるシミュレーションを補助するシェル(新しめのbash) ... FIREshellscript/

"どっか"に LIBの中身を入れる。(numerical recipeのライブラリとEIGENのライブラリ)

シミュレーションコンパイル時は、"どっか"=~/lib とすると、
g++ -I "~/lib" TestProgram_FVVmodified.cpp -o FIREVV
的な感じで実行ファイル作ればおｋ. (アウトプットファイルはFIREVVにしておくと、僕の作ったシェルスクリプトそのまま使えるので)

hoge/BI3DN512 (3次元粒子数512) とかに実行ファイル入れて、このディレクトリ内で実行すればテキストデータで座標、固有モード情報、スケジューリング情報、接触数分布などが生成される。
hogeは適当なディレクトリ。混合比変える場合はBI3DN512_1by3としておくと多分一緒に統計取ってくれる。
hoge内に様々な粒子数のものを入れておくと、あとで統計取る際に一緒に処理してくれる。

統計解析プログラム群は、Analysis/Fstat_compile.shで一斉にコンパイルしてくれる。
生成された実行ファイル群とシェル群をまとめてhogeの中に入れて、sample_routine.shを実行するとサンプル統計情報(ジャミング転移点、固有モード情報など)が新たに生成される。
新たに生成されたディレクトリにstat_routineを入れて、実行してやると一連の流れで統計シェルが動いて、状態密度やIPRの統計平均(Additional_SM...や、OMEGA_STARの情報(SM_cfreq2.txt)などが生成される。)
